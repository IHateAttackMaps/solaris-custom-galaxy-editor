import helper from "../helper";
import type { MapGenerator } from "../types/Generator";
import type { Location } from "../types/Location";
import { createNoise2D, type NoiseFunction2D } from 'simplex-noise';
import storage from '../storage';
import SeededRandomGen from '../util/seededRandomGen';

class IrregularNLimitMapGenerator implements MapGenerator {

    //TODO this is generator agnostic and could be on a base class or service
    _removeLocationFromArray(array: Location[], location: Location) {
        let index = array.indexOf(location);
        array.splice(index, 1);
    }

    _rotatedLocation(location: Location, angle: number) {
        return helper.getRotatedLocation(location, -angle);
    }

    //TODO this is generator agnostic and could be on a base class or service
    _displacedLocation(location1: Location, location2: Location) {
        return {
            x: location1.x + location2.x,
            y: location1.y + location2.y,
        };
    }

    _generateHexGrid(playerCount: number, pivotDistance: number) {
        const X_OFFSET = Math.sqrt(3.0) / 2.0;
        const ONE_HALF = 1.0 / 2.0;
        const scaleFactor = pivotDistance * Math.sqrt(3.0);

        const gridRadius = Math.ceil(Math.sqrt(3.0 * playerCount - 3.0));
        const grid: Location[] = [];

        for (let x = -gridRadius + 1; x < gridRadius; x++) {
            if (x % 2 === 0) {
                for (let y = -gridRadius + 1 + x; y < gridRadius - x; y++) {
                    grid.push({ x: (x * X_OFFSET) * scaleFactor, y: y * scaleFactor });
                }
            } else {
                for (let y = -gridRadius + 1 + x; y < gridRadius - x; y++) {
                    grid.push({ x: (x * X_OFFSET) * scaleFactor, y: (y + ONE_HALF) * scaleFactor });
                }
            }
        }

        return grid;
    }

    _getNeighbours(location: Location, homeLocations: Location[], pivotDistance: number) {
        const ONE_SIXTH = 1.0 / 6.0;
        const TAU = 2.0 * Math.PI;

        let neighbours = [];
        for (let i = 0; i < 6; i++) {
            let pivot = { x: pivotDistance * Math.sqrt(3.0), y: 0.0 };
            let pivotRotation = ONE_SIXTH * TAU * i + ONE_SIXTH * Math.PI;
            pivot = this._rotatedLocation(pivot, pivotRotation);
            pivot = this._displacedLocation(location, pivot);

            for (const other of homeLocations) {
                if (helper.getDistanceBetweenLocations(pivot, other) < 1) {
                    neighbours.push(other);
                }
            }
        }

        return neighbours;
    }

    _getNonRemovedNeighbours(location: Location, homeLocations: Location[], pivotDistance: number) {
        return this._getNeighbours(location, homeLocations, pivotDistance).filter(l => (l as any).removed == null);
    }

    _selectRandomValidNeighboursForRemoval(location: Location, homeLocations: Location[], pivotDistance: number, minNeighbours: number, maxNeighbours: number, rand: SeededRandomGen) {
        const neighbours = this._getNonRemovedNeighbours(location, homeLocations, pivotDistance);
        const neighbourCount = neighbours.length;

        const validNeighbours = neighbours.filter(l => (l as any).selected == null);

        if (neighbourCount <= minNeighbours) return;
        let toRemove = rand.getRandomNumberBetween(Math.max(neighbourCount - maxNeighbours, 0), neighbourCount - minNeighbours);

        if (neighbourCount < toRemove) throw new Error(`Attempted to remove more valid neighbours than exist!`);
        toRemove = Math.min(toRemove, validNeighbours.length);

        const removedNeighbours: Location[] = [];
        for (let i = 0; i < toRemove; i++) {
            removedNeighbours.push(validNeighbours[rand.getRandomNumber(validNeighbours.length - 1)]);
        }

        return removedNeighbours;
    }

    // get how many rings of stars will be necessary to have at least starPerPlayerMin stars per player
    // then try to use as many rings as possible without going over starPerPlayerMax amount of stars per player
    _getRingCount(starsPerPlayerMin: number, starsPerPlayerMax: number) {
        let ringCount = this._getNecessaryRingCount(starsPerPlayerMin) + 1
        while (this._getStarCountInRings(ringCount) < starsPerPlayerMax) {
            ringCount += 1
        }
        return ringCount - 1 // -1 since the current count is actually 1 above
    }

    // get how many stars per player will be generated by using ringCount number of rings
    _getStarCountInRings(ringCount: number) {
        let starCount = 0;
        let ringIndex = 0;
        let lastRingPruning = 0;
        while (ringIndex < ringCount) {
            starCount += lastRingPruning; // refill the last ring with the pruned stars since this ring is no longer the last one
            starCount += 6 + (ringIndex * 6); // each ring on a hexagonal grid will have this amount of stars, this is not tweakable
            // last ring(outer ring) will actually have less stars. this is to ensure a perfect hexagonal tiling withouth any stars overlapping, values are not tweakable
            lastRingPruning = 4 + ((ringIndex * 6) / 2);
            starCount -= lastRingPruning;
            ringIndex += 1;
        }
        return starCount;
    }

    // get how many rings of stars  will be necessary to have at least starsPerPlayer stars generated per player
    _getNecessaryRingCount(starsPerPlayer: number) {
        let starCount = 0;
        let ringIndex = 0;
        let lastRingPruning = 0;
        while (starCount < starsPerPlayer) {
            starCount += lastRingPruning;
            starCount += 6 + (ringIndex * 6);
            lastRingPruning = 4 + ((ringIndex * 6) / 2);
            starCount -= lastRingPruning;
            ringIndex += 1;
        }
        return ringIndex;
    }

    _generateHomeLocations(pivotDistance: number, playerCount: number, rand: SeededRandomGen) {
        const MIN_NEIGHBOURS = 3;
        const MAX_NEIGHBOURS = 5;
        const FIX_ROUNDS = 2;

        let homeLocations: Location[] = this._generateHexGrid(playerCount, pivotDistance);

        let selectionQueue: Location[] = [];
        const origin = homeLocations.find(l => l.x === 0 && l.y === 0)!;
        selectionQueue.push(origin);

        let numSelected = 0;
        while (numSelected < playerCount) {
            let current = selectionQueue.shift();
            if (current == null) {
                // It might be possible to end up here?
                throw new Error(`Attempted to get element from empty queue!`);
            }
            (current as any).selected = true;
            numSelected++;

            const removed = this._selectRandomValidNeighboursForRemoval(current, homeLocations, pivotDistance, MIN_NEIGHBOURS, MAX_NEIGHBOURS, rand);

            if (removed) {
                selectionQueue = selectionQueue.filter(l => !removed.includes(l));
                removed.forEach(l => (l as any).removed = true);
            }

            const neighbours = this._getNonRemovedNeighbours(current, homeLocations, pivotDistance).sort((a, b) => helper.getDistanceBetweenLocations(origin, a) - helper.getDistanceBetweenLocations(origin, b));
            for (const neighbour of neighbours) {
                if ((neighbour as any).selected == null && (neighbour as any).marked == null) {
                    (neighbour as any).marked = true;
                    selectionQueue.push(neighbour);
                }
            }
        }

        homeLocations.forEach(l => {
            if ((l as any).selected == null) {
                (l as any).removed = true;
            }
        });

        for (let n = 0; n < FIX_ROUNDS; n++) {
            let goodHoles = [];
            let badLocs = [];
            for (const location of homeLocations) {
                const neighbourCount = this._getNonRemovedNeighbours(location, homeLocations, pivotDistance).length;
                if (neighbourCount >= MIN_NEIGHBOURS && neighbourCount <= MAX_NEIGHBOURS) {
                    if ((location as any).removed === true) goodHoles.push(location);
                } else {
                    if ((location as any).removed == null && (location as any).selected === true) badLocs.push(location);
                }
            }
            helper.shuffleArray(goodHoles);
            helper.shuffleArray(badLocs);

            if (badLocs.length > goodHoles.length) {
                badLocs.length = goodHoles.length;
            }

            for (let i = 0; i < badLocs.length; i++) {
                (badLocs[i] as any).removed = true;
                (badLocs[i] as any).selected = undefined;
                (goodHoles[i] as any).removed = undefined;
                (goodHoles[i] as any).selected = true;
            }
        }

        homeLocations = homeLocations.filter(l => (l as any).selected === true);

        return homeLocations;
    }

    _generateSupplementaryHomeLocations(pivotDistance: number, homeLocations: Location[]) {
        const ONE_SIXTH = 1.0 / 6.0;
        const TAU = 2.0 * Math.PI;

        let supplementaryHomeLocations: Location[] = [];

        for (let homeLocation of homeLocations) {
            for (let i = 0; i < 6; i++) {
                let pivot = { x: pivotDistance, y: 0.0 };
                let pivotRotation = ONE_SIXTH * TAU * i;
                pivot = this._rotatedLocation(pivot, pivotRotation);
                pivot = this._displacedLocation(homeLocation, pivot);

                let position = { x: pivotDistance, y: 0.0 };
                let rotation = (ONE_SIXTH * TAU) * (i + 1)
                position = this._rotatedLocation(position, rotation);
                position = this._displacedLocation(pivot, position);

                let isValidPosiiton = true;
                for (let homeLocation of homeLocations) {
                    if (helper.getDistanceBetweenLocations(homeLocation, position) < pivotDistance) {
                        isValidPosiiton = false;
                    }
                }
                for (let supplementaryHomeLocation of supplementaryHomeLocations) {
                    if (helper.getDistanceBetweenLocations(supplementaryHomeLocation, position) < pivotDistance) {
                        isValidPosiiton = false;
                    }
                }
                if (isValidPosiiton) {
                    supplementaryHomeLocations.push(position);
                }
            }
        }
        return supplementaryHomeLocations;
    }

    //populates the given `locations` array with new locations around the `baseLocation`
    //locations are created in hexagonal rings around the base locations, respecting a triangular grid
    _generateConcentricHexRingsLocations(baseLocation: Location, ringCount: number, distance: number, locations: Location[]) {
        const ONE_SIXTH = 1.0 / 6.0;
        const TAU = 2.0 * Math.PI;

        for (let ringIndex = 0; ringIndex < ringCount; ringIndex++) {
            for (let sliceIndex = 0; sliceIndex < 6; sliceIndex++) {
                if ((ringIndex == (ringCount - 1)) && (sliceIndex < 3)) { continue; } //only create the first 3 edges of the outer ring

                let position = { x: distance + (distance * ringIndex), y: 0.0 };
                let rotation = sliceIndex * ONE_SIXTH * TAU;
                position = this._rotatedLocation(position, rotation);
                position = this._displacedLocation(baseLocation, position);

                if ((ringIndex != (ringCount - 1)) || (sliceIndex == 3) || (sliceIndex == 4)) {
                    //only add 2 of the corner stars for the last ring
                    locations.push(position);
                }

                for (let i = 0; i < ringIndex; i++) {
                    let edgePosition = { x: distance * (i + 1), y: 0.0 };
                    let edgeRotation = (sliceIndex + 2) * (ONE_SIXTH * TAU);
                    edgePosition = this._rotatedLocation(edgePosition, edgeRotation);
                    edgePosition = this._displacedLocation(position, edgePosition);
                    locations.push(edgePosition);
                }
            }
        }
    }

    _randomlyDislocateLocations(locations: Location[], threshold: number, rand: SeededRandomGen) {
        const TAU = 2.0 * Math.PI;

        for (let location of locations) {
            let amount = (3.0 * (threshold / 4.0)) + ((rand.random() * threshold) / 4.0); // 0.75 to 1.0 times the threshold
            let rotation = rand.random() * TAU
            let dislocation = { x: amount, y: 0.0 };
            dislocation = this._rotatedLocation(dislocation, rotation);
            let newLocation = this._displacedLocation(location, dislocation);

            location.x = newLocation.x;
            location.y = newLocation.y;
        }
    }

    _pruneLocationsWithNoise(locations: Location[], desiredLocationCount: number, simplexNoiseGenerator: NoiseFunction2D, noiseSpread: number) {
        for (let location of locations) {
            (location as any).noiseIntensity = simplexNoiseGenerator(location.x / noiseSpread, location.y / noiseSpread);
        }
        locations.sort((loc1, loc2) => {
            return ((loc1 as any).noiseIntensity - (loc2 as any).noiseIntensity);
        });
        locations.splice(desiredLocationCount);
    }

    //removes locations outside the metaball composed of home locations
    //locations have a chance of beeing removed based on the distance from the metaball
    _pruneLocationsOutsideMetaball(locations: Location[], homeLocations: Location[], homeStarRadius: number, rand: SeededRandomGen) {
        const METABALL_FALLOFF = 8.0; //higher values reduces the spread of the metaball
        // probably better not to remove items while iterating, so add to this array instead
        let toRemove: Location[] = [];
        for (let location of locations) {
            let metaballFieldIntensity = 0;
            for (let homeLocation of homeLocations) {
                let distance = helper.getDistanceBetweenLocations(homeLocation, location);
                distance = homeStarRadius / distance;
                metaballFieldIntensity += Math.pow(distance, METABALL_FALLOFF);
            }
            let chanceToRemove = 1.0 - metaballFieldIntensity;
            if (rand.random() < chanceToRemove) {
                toRemove.push(location);
            }
        }
        for (let location of toRemove) {
            this._removeLocationFromArray(locations, location);
        }

    }

    generateLocations(playerCount: number, starsPerPlayer: number, seed: string | null | undefined, startingStars?: number, initialHyperspaceRange?: number): Location[] {
        if (!startingStars) throw new Error(`Starting star count must be provided for the Irregular generator!`);
        if (!initialHyperspaceRange) throw new Error(`Minimum hyperspace range must be provided for the Irregular generator!`);
        if (!seed) seed = (Math.random() * Number.MAX_SAFE_INTEGER).toFixed(0);

        const rand = new SeededRandomGen(seed);

        const starCount = playerCount * starsPerPlayer;
        const SPREAD = 2.5;
        const SIMPLEX_NOISE = createNoise2D(rand.random);
        const NOISE_BASE_SPREAD = 32.0;
        //const NOISE_SPREAD = NOISE_BASE_SPREAD * Math.sqrt(starCount*1.3);// try to make the noise spread with the size of the galaxy. this makes the void gaps also proportional to galaxy size. 
        //const NOISE_SPREAD = 512; //optionally could keep the voids constant in size, no matter the galaxy size
        const TAU = 2.0 * Math.PI;
        const STARS_PER_PLAYER = starCount / playerCount;
        const INITIAL_HYPER_RANGE = initialHyperspaceRange;
        const STARTING_STAR_COUNT = startingStars - 1;
        const MINIMUM_STAR_DISTANCE = storage.getSettings().generation.minDistanceBetweenStars * 0.75; // TODO: This is a bit of a bodge to ensure that stars do not spawn too far away from players.

        const NOISE_SPREAD = NOISE_BASE_SPREAD * ((STARS_PER_PLAYER + 20) / 9.0)

        //the amount of rings must produce about 30% more stars then requested. this way they can be pruned latter with noise to produce nice gap
        const STAR_COUNT_MULTIPLIER = 1.3;
        const RING_COUNT = this._getRingCount(STARS_PER_PLAYER, (STARS_PER_PLAYER * STAR_COUNT_MULTIPLIER));
        const STAR_DISTANCE = MINIMUM_STAR_DISTANCE * SPREAD;
        const STAR_DISLOCATION_THRESHOLD = MINIMUM_STAR_DISTANCE * ((SPREAD - 1.0) / 2.0);
        const PIVOT_DISTANCE = RING_COUNT * STAR_DISTANCE;

        let locations: Location[] = [];
        let homeLocations = this._generateHomeLocations(PIVOT_DISTANCE, playerCount, rand);
        let supplementaryHomeLocations = this._generateSupplementaryHomeLocations(PIVOT_DISTANCE, homeLocations);
        let baseLocations: Location[] = [];
        let supplementaryLocations: Location[] = [];


        for (let homeLocation of homeLocations) {
            this._generateConcentricHexRingsLocations(homeLocation, RING_COUNT, STAR_DISTANCE, baseLocations);
        }
        for (let supplementaryHomeLocation of supplementaryHomeLocations) {
            this._generateConcentricHexRingsLocations(supplementaryHomeLocation, RING_COUNT, STAR_DISTANCE, supplementaryLocations);
        }

        locations = locations.concat(baseLocations, supplementaryLocations);

        this._pruneLocationsOutsideMetaball(locations, homeLocations, PIVOT_DISTANCE, rand);
        this._randomlyDislocateLocations(locations, STAR_DISLOCATION_THRESHOLD, rand);
        this._pruneLocationsWithNoise(locations, (starCount - playerCount), SIMPLEX_NOISE, NOISE_SPREAD);



        //------------------------------------------------------------------------------------------

        //TODO move the selecting star logic to its own function that is mapgen agnostic
        //TODO move the pulling star logic --/--

        for (let homeLocation of homeLocations) {
            (homeLocation as any).homeStar = true;
            (homeLocation as any).linkedLocations = [];
        }


        let unlinkedLocations = locations.filter((loc) => { return true; });
        let startingStarsCount = STARTING_STAR_COUNT;

        while (startingStarsCount--) {
            for (let homeLocation of homeLocations) {
                let closestUnlinkedLocation = helper.getClosestLocations(homeLocation, unlinkedLocations, 1)[0] as any;
                (homeLocation as any).linkedLocations.push(closestUnlinkedLocation);
                closestUnlinkedLocation.linked = true;
                unlinkedLocations = unlinkedLocations.filter((loc) => { return loc !== closestUnlinkedLocation; });
            }
        }

        // pull the closest stars that will be linked so they are in hyper range
        let minimumClaimDistance = helper.getHyperspaceDistanceByLevel(INITIAL_HYPER_RANGE) - 2; //-2 to avoid floating point imprecisions

        for (let homeLocation of homeLocations) {
            let reachableLocations: Location[] = [];
            let unreachebleLocations: Location[] = [];

            reachableLocations.push(homeLocation);

            for (let location of (homeLocation as any).linkedLocations) {
                unreachebleLocations.push(location);
            }

            while (unreachebleLocations.length > 0) {
                //find the unreachable location that is closer to any of the reachable locations
                for (let unreachebleLocation of unreachebleLocations) {
                    let distanceToClosestReachable;
                    let closestReachableLocation;
                    let smallestDistance = Number.MAX_VALUE;

                    for (let reachableLocation of reachableLocations) {
                        let distance = helper.getDistanceBetweenLocations(unreachebleLocation, reachableLocation);

                        if (distance < smallestDistance) {
                            smallestDistance = distance;
                            distanceToClosestReachable = distance;
                            closestReachableLocation = reachableLocation;
                        }
                    }

                    (unreachebleLocation as any).distanceToClosestReachable = distanceToClosestReachable;
                    (unreachebleLocation as any).closestReachable = closestReachableLocation;
                }

                let closestUnreachable = unreachebleLocations[0];

                for (let unreachebleLocation of unreachebleLocations) {
                    if ((unreachebleLocation as any).distanceToClosestReachable < (closestUnreachable as any).distanceToClosestReachable) {
                        closestUnreachable = unreachebleLocation;
                    }
                }

                helper.moveLocationTowards(closestUnreachable, (closestUnreachable as any).closestReachable, minimumClaimDistance);

                // after moving closer we can change the location from the unreachable to the reachable array
                unreachebleLocations.splice(unreachebleLocations.indexOf(closestUnreachable), 1);
                reachableLocations.push(closestUnreachable);
            }

            //now all linked stars should be reachable
        }

        locations = locations.concat(homeLocations);

        return locations;
    }
}

export default new IrregularNLimitMapGenerator();